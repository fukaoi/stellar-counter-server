<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{% block title %}{% endblock %}</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/stellar-sdk/0.11.0/stellar-sdk.js"></script>

  
  <style>
    body {
      padding: 80px;
      font: 16px Helvetica, Arial;
    }

    a {
      color: #3A9AC2;
    }

    h1 {
      font-size: 2em;
    }

    h2 {
      font-size: 1.2em;
    }

    table {
      width:1440px;
      border-collapse:collapse;
    }

    tbody tr {
      border-top: 1px solid #dddd;
      height: 40px;
    }
    
    #header-lumen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 20px;
      padding: 10px;
      background-color: #3A9AC2;
      color: #ffffff;
      text-align: center;
    }

    #header-token {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 20px;
      padding: 10px;
      background-color: rgb(97, 194, 58);
      color: #ffffff;
      text-align: center;
    }

    textarea {
      width: 500px;
      height: 300px;
    }

    input[type = text],
      textarea {
      border: 1px solid #eee;
      border-top-color: #ddd;
      border-left-color: #ddd;
      border-radius: 2px;
      padding: 15px;
      font-size: .8em;
    }

    input[type = submit] {
      width: 100px;
      height: 45px;
      font-size: 105%;
    }

    input[type = text] {
      width: 500px;
    }
  </style>  

<body>
  <div id="{{ header }}">Only testnet in stellar network</div>
  <section id="content">
    {% block content %}
    <p>Missing content!</p>
    {% endblock %}
  </section>
</body>

<script>
  let receive_pool = []
  let send_pool = []

  const html = (message) =>
    `<tr class="transition" id="${message.transaction_hash}">
      <td align="left">
        <a href="https://testnet.steexp.com/tx/${message.transaction_hash}" target="_blank">${message.from}</a>
      </td>
      <td align="right">${message.amount}</td>
      <td align="center" width="200px" class="memo"> </td>
      <td align="right">${message.created_at}</td>
    </tr>`


  const txinfo = (message) => {
    let elementId
    if (message.from == '{{publicKey}}') {
      elementId = 'sendLists'
      send_pool.push(message.transaction_hash)
    } else {
      elementId = 'receiveLists'
      receive_pool.push(message.transaction_hash)
    }
    document.getElementById(elementId).insertAdjacentHTML('afterbegin', html(message))
  }

  const viewLimitter = (limit = '{{limit}}') => {
    if (receive_pool.length > Number(limit)) {
      const txHash = receive_pool.shift()
      document.getElementById(txHash).remove()
    }

    if (send_pool.length > Number(limit)) {
      const txHash = receive_pool.shift()
      document.getElementById(txHash).remove()
    }
  }

  function base64ToArrayBuffer(base64) {
    if (base64 == undefined) return
    var binary_string = window.atob(base64)
    var len = binary_string.length
    var bytes = new Uint8Array(len)
    for (let i = 0; i < len; i++) {
      bytes[i] = binary_string.charCodeAt(i)
    }
    return Array.from(bytes).map(v => ('00' + v.toString(16)).slice(-2)).join('')
  }


  const memo = (message) => {
    message.transaction().then((tx) => {
      if (message.from == '{{publicKey}}') {
        const memo_hex = base64ToArrayBuffer(tx.memo).toUpperCase();
        if (tx.memo_type == 'hash') document.getElementById(tx.hash).children[2].innerText = memo_hex
      } else {
        if (tx.memo_type == 'text') document.getElementById(tx.hash).children[2].innerText = tx.memo
        if (tx.memo == 'reply') {
          send({
            publickey: message.from, 
            amount: message.amount,
            txhash: tx.hash
          })
        }
      }
    })
  }

  const send = (data) => {
    fetch('http://localhost:3000/send', {
      method: "post",
      cache: "no-cache",
      headers: { "Content-Type": "application/json charset=utf-8" },
      body: JSON.stringify(data),
    })
      .then(response => console.log(response))
  }

  const main = (txinfo_callback, memo_callback) => {
    new StellarSdk.Server("{{horizonUrl}}")
      .payments().forAccount("{{publicKey}}").cursor('now').stream({
        onmessage: (message) => {
          if (message.from == undefined) return
          txinfo_callback(message)
          memo_callback(message)
          viewLimitter()
        }
      })
  }

  window.onload = () => {
    main(txinfo, memo)
  }
</script>
</html>