{% extends 'layout.html' %}

{% block title %}Lumen{% endblock %}

{% block content %}

<p>
  <h1>{{publicKey}}</h1>Reply server address
</p>

<h1>Sended XLM</h1>
<p>Reply server sended XLM lists!</p>
<table id="sendLists"></table>

<h1>Received XLM</h1>
<p>Your sended XLM lists!</p>
<table id="receiveLists"></table>

<script>
  const txinfo = (message) => {
    const html =
      `<tr class="transition" id="${message.transaction_hash}">
      <td align="left">
        <a href="https://testnet.steexp.com/tx/${message.transaction_hash}" target="_blank">${message.from}</a>
      </td>
      <td align="right">${message.amount}</td>
      <td align="center" width="200px" class="memo"> </td>
      <td align="right">${message.created_at}</td>
    </tr>`;
    const elementId = message.from == '{{publicKey}}' ? 'sendLists' : 'receiveLists';
    document.getElementById(elementId).insertAdjacentHTML('afterbegin', html);
  }

  const receive_memo = (message) => {
    message.transaction().then((tx) => {
      if (tx.memo_type == 'text') {
        document.getElementById(tx.hash).children[2].innerText = tx.memo;
    // if (tx.memo == 'reply') {
    //   send({
    //     publickey: message.from, 
    //     amount: message.amount,
    //     txhash: tx.hash
    //   });
    // }
    }
    });
  }

  const memo = (message) => {
    message.transaction().then((tx) => {
      if (message.from == '{{publicKey}}') {
        if (tx.memo_type == 'hash') document.getElementById(tx.hash).children[2].innerText = tx.memo;
      } else {
        if (tx.memo_type == 'text') document.getElementById(tx.hash).children[2].innerText = tx.memo;
      } 
    });
  }

  const send = (data) => {
    fetch('http://localhost:3000/send', {
      method: "POST",
      cache: "no-cache",
      headers: { "Content-Type": "application/json; charset=utf-8" },
      body: JSON.stringify(data),
    })
      .then(response => console.log(response));
  }

  const stream = (txinfo_callback, memo_callback) => {
    new StellarSdk.Server("{{horizonUrl}}")
      .payments().forAccount("{{publicKey}}").cursor().stream({
        onmessage: (message) => {
          if (message.from == undefined) return;
          txinfo_callback(message);
          memo_callback(message);
        }
      });
  }

  window.onload = () => stream(txinfo, memo);
</script>
{% endblock %}